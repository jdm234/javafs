function sayHello(name){
	console.log("Hello, " + name + "!");
}
sayHello("john");


람다식
const sayHello = (name) => {
	console.log("Hello, " + name + "!");
};

sayHello("John");

const numbers = [1,2,3,4,5];
let sum = 0;
for(let i = 0 ; i < numbers.length; i++){
	sum += numbers[i];
}
console.log("Sum:", sum);

const numbers = [1,2,3,4,5]; // 배열
const sum = numbers.reduce((acc, curr) => acc + curr, 0);
// acc - 누적값을 나타내며, 이전 단계에서 반환된 값이 저장
// curr : 현재 요소의 값 - 배열의 각 요소을 순회하면서 차례대로 전달
// 0 - 두번째 매개변수의 초기값(curr)
console.log("Sum:", sum);

자바
List<String> fruits = Arrays.asList("Apple", "Banana", "Orange");
for(String fruit : fruits){
	System.out.println(fruit);
}

List<String> fruits = Arrays.asList("Apple", "Banana", "Orange");

fruits.forEach(fruit -> System.out.println(fruit);

람다2
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
List<Integer> evenNumbers = new ArrayList<>();
for(Integer number : numbers){
	if (number % 2 == 0) {
	evenNubers.add(number);
     }
}

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

List<Integer> evenNumbers = numbers.stream()
				.filter(number -> number % 2 == 0)
				.collect(Collectors.toList()):

스트림생성
1. 컬렉션
2. 배열
3. 가변 매개변수
4. 지정된 범위의 연속된정수
5. 특정 타입읜 난수들
6. 람다 표현식
7. 파일
8. 빈 스트림

스트림의 중개 연산(intermediate operation)
스트림 API에 의해 생성된 초기 스트림은 중개 연산을 통해 또 다른 스트림으로 변환됩니다.

이러한 중개 연산은 스트림을 전달받아 스트림을 반환하므로, 중개 연산은 연속으로 연결해서 사용할 수 있습니다.

또한, 스트림의 중개 연산은 필터-맵(filter-map) 기반의 API를 사용함으로 지연(lazy) 연산을 통해 성능을 최적화할 수 있습니다.


스트림 API에서 사용할 수 있는 대표적인 중개 연산과 그에 따른 메소드는 다음과 같습니다.
1. 스트림 필터링 : filter(), distinct()

2. 스트림 변환 : map(), flatMap()

3. 스트림 제한 : limit(), skip()

4. 스트림 정렬 : sorted()

5. 스트림 연산 결과 확인 : peek()

스트림의 최종 연산(terminal operation)
스트림 API에서 중개 연산을 통해 변환된 스트림은 마지막으로 최종 연산을 통해 각 요소를 소모하여 결과를 표시합니다.

즉, 지연(lazy)되었던 모든 중개 연산들이 최종 연산 시에 모두 수행되는 것입니다.

이렇게 최종 연산 시에 모든 요소를 소모한 해당 스트림은 더는 사용할 수 없게 됩니다.

 

스트림 API에서 사용할 수 있는 대표적인 최종 연산과 그에 따른 메소드는 다음과 같습니다.

1. 요소의 출력 : forEach()

2. 요소의 소모 : reduce()

3. 요소의 검색 : findFirst(), findAny()

4. 요소의 검사 : anyMatch(), allMatch(), noneMatch()

5. 요소의 통계 : count(), min(), max()

6. 요소의 연산 : sum(), average()

7. 요소의 수집 : collect()